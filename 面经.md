### Typora常用命令

最大标题：command + 1 或者：#
大标题：command + 2 或者：##
标准标题：command + 3 或者：###
中标题：command + 4 或者：####
小标题：command + 5 或者：#####
插入表格：command + T
插入代码：command + option +c
行间公式 command + option + b
段落：command + 0
竖线 ： command + option +q
有序列表（1. 2.） ：输入数字+“.”之后输入空格 或者：command + option + o
黑点标记：command + option + u
隔离线shift + command + -
超链接：command + option + l
插入链接：command +k
下划线：command +u
加粗：command +b
搜索：command +f



### JS（let const var）

var let const

![image-20220723005836342](面经.assets/image-20220723005836342.png)

1. const声明之后必须赋值
2. 定义的值不能修改，否则报错
3. 支持let其他属性
4. 常量一般要大写

#### 解构赋值

![image-20220723010201231](面经.assets/image-20220723010201231.png)

![image-20220723010334361](面经.assets/image-20220723010334361.png)

### 原型，原型链

![image-20220723013340703](面经.assets/image-20220723013340703.png)

原型 prototype 原型链 _proto_

只有函数特有原型 prototype， 原型链是任何数据类型都有的

![image-20220723014213035](面经.assets/image-20220723014213035.png)

### 防抖函数

当持续触发事件，一定时间又没有再触发事件，事件函数才会再执行一次

如果设定的时间在到来之前，又一次触发了事件，就重新开始延时

触发事件一段时间内没有触发，事件执行，肯定就是定时器 ![image-20220723014836748](面经.assets/image-20220723014836748.png)

### 节流函数

![image-20220723015640355](面经.assets/image-20220723015640355.png)

节流 =》一定时间内多个事件合并为一个事件

防抖 =》固定时间内事件只允许发生一次

### 闭包

1. 延长变量的生命周期
2. 创建私有环境

![image-20220723021714641](面经.assets/image-20220723021714641.png)

### Undefined和Null

![image-20220723172916889](面经.assets/image-20220723172916889.png)

![image-20220723173011719](面经.assets/image-20220723173011719.png)

### Vue应用层 V-model

双向数据绑定

### Vue生命周期

![image-20220724121315865](面经.assets/image-20220724121315865.png)

beforeCreated()  data和methods还没有初始化，所以一般在这个阶段也不做什么操作

Created() 组件实例化之后，data和methods已经初始化完成了，可以供我们使用，但是模板还没有编译，也就是我们没法获取DOM(因为Vue就是把DOM树解析成虚拟DOM)，通常在这个阶段做一些发送请求的操作

beforeMounted() 该钩子函数在模板渲染之前调用，也就是DOM节点挂载到真实DOM树之前调用，此时模板会进行编译，会调用render函数生成vDOM，也就是虚拟DOM， 此时我们同样无法获取DOM节点

Mounted() 模板已经编译好了，挂载到DOM树上去了，能获取到DOM节点

beforeUpdate() 当我们页面和组件发生变化时，便会执行对应的更新阶段的钩子函数

该钩子函数在data数据发生变化之后调用，此时data里面的数据已经是最新的了，但是页面上DOM还没有更新最新的数据

Updated()  此钩子函数会在数据更新之后执行，而且此时页面渲染也已经完成了，显示的就是最新的数据 <strong>不要在update中修改data数据，很容易造成死循环</strong>

beforeDestroy() 此时组件还没有被销毁，还可以正常使用，我们通常在这个钩子函数里面解除一些全局或者自定义事件

Destroyed() 此钩子函数会在组件实例化销毁之后执行，此时所有组件包括子组件都被销毁了

```js
let x = 10;
let foo = () =>{
  console.log(x);
  let x = 20;
  x++;
}
foo();
// 使用let声明的变量，既不会发生变量提升，同时又存在暂时性死区，所以在块级作用域内，如果使用let声明一个变量，那么该变量在声明之前是不可用的，否则会抛出ReferenceError异常
```

```js
isNaN("100"); //false
isNaN(null); //false
// null 可以转换成为数字，不能转换成NaN
```

### 回流与重绘
1. 浏览器采用流式布局
2. 首先HTML解析成DOM，把CSS解析成CSSOM，把CSSDOM与DOM结合产生render tree
3. 有render tree以后，我们知道了节点样式，然后浏览器会计算节点位置，然后把节点绘制到页面上

####   回流

当我们render tree中的一些元素的结构或者尺寸发生改变，浏览器会重新渲染部分或者全部文档

- 浏览器渲染
- 浏览器窗口发生变化
- 内容变换
- 添加或者删除节点
- 激活css伪类
- clientWidth

#### 重绘

当页面中元素样式的改变不影响它在文档中的位置，浏览器会将新样式赋予元素，这个过程叫做重绘

- background
- visibility

#### 性能影响

总结： 回流的性能消耗比重绘大